package pathfinding;

import logging.Logger;
import model.*;

import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static com.mapbox.turf.TurfJoins.inside;

/**
 * Class that takes a path generated by the A* search and converts it into valid drone moves
 */
public class LineApproximation {

    /**
     * method to approximate a single LineSegment as a series of DroneMoves
     * @param start Point to start approximating from
     * @param end Point to approximate to
     * @param noFlyZones List of Polygons containing no-fly zones
     * @return List of DroneMove
     */
    private static List<DroneMove> approximateSegment(Point start, Point end, List<Polygon> noFlyZones){
        Logger logger = Logger.getInstance();

        // make sure no null arguments have been passed
        if (start == null || end == null || noFlyZones == null){
            logger.logAction("LineApproximation.approximateSegment(start, end, noFlyZones", LogStatus.LINE_APPROXIMATION_NULL_ARGUMENT);
            return new ArrayList<>();
        }

        List<DroneMove> moves = new ArrayList<>();
        List<DroneMove> badMoves = new ArrayList<>();
        boolean complete = false;

        // get all possible directions the drone can move
        var directions = CompassDirection.values();
        Point current = start;

        // repeat until we are "closeTo" the goal
        while (!complete) {
            //TODO: make sure that there is a "betterMove or a valid Move"
            //TODO: if there isn't, go back and find the next best move
            //boolean bestMoveFound

            // find the directions we can move and still have a valid point
            List<CompassDirection> validAngles = new ArrayList<>();
            for (var angle : directions) {
                Point move = current.makeMove(angle);
                var segment = new LineSegment(move, current);
                // conditions for validity:
                // doesn't intersect an edge of a no-fly zone
                // the resulting point isn't inside a no-fly zone
                // we aren't repeating a move we have already done (prevents loops)
                var doesIntersect = intersectsNoFlyZone(noFlyZones, segment);
                var isInside = insideNoFlyZone(noFlyZones, move);
                if (!(doesIntersect ||
                        isInside ||
                        moreThanOneOccurrence(moves, new DroneMove(current, move, angle.bearing)) ||
                        badMoves.contains(new DroneMove(current, move, angle.bearing)))
                ) {
                    validAngles.add(angle);
                }
            }

            // if there is a valid move
            if (validAngles.size() > 0) {
                // find the best move (reduces distance to goal the most)
                CompassDirection bestAngle = validAngles.get(0);
                Point bestMove = current.makeMove(bestAngle);
                for (var angle : validAngles) {
                    Point move = current.makeMove(angle);
                    if (move.distanceTo(end) < bestMove.distanceTo(end)) {
                        bestMove = move;
                        bestAngle = angle;
                    }
                }
                // add move to list of moves
                moves.add(new DroneMove(current, bestMove, bestAngle.bearing));
                current = bestMove;
                // if we are "closeTo" the goal, stop
                if(bestMove.closeTo(end)){
                    complete = true;
                }
            } else {
                // if there are no valid moves:
                // go back a move, add the move that was just completed to a badMoves list
                // and remove that move from the list of moves
                current = moves.get(moves.size() - 1).from();
                badMoves.add(moves.get(moves.size() - 1));
                moves.remove(moves.size() - 1);
            }
        }
        return moves;
    }

    /**
     * method to check whether a LineSegment intersects any no-fly zones
     * @param noFlyZones List of Polygons containing no-fly zones
     * @param segment LineSegment to check
     * @return true if there is an intersection, false otherwise
     */
    private static boolean intersectsNoFlyZone(List<Polygon> noFlyZones, LineSegment segment){
        boolean intersect = false;
        for (var noflyzone : noFlyZones){
            List<LineSegment> edges = noflyzone.getLineSegments();
            // intersect will be set to true if there are ANY intersects
            for (LineSegment edge : edges){
                intersect = intersect ||  Line2D.linesIntersect(edge.p1().lng(), edge.p1().lat(),
                        edge.p2().lng(), edge.p2().lat(),
                        segment.p1().lng(), segment.p1().lat(),
                        segment.p2().lng(), segment.p2().lat());
            }
        }
        return intersect;
    }

    /**
     * check if a given Point is inside any no-fly zones
     * @param noFlyZones List of Polygons containing no-fly zones
     * @param move Point
     * @return true if inside, false otherwise
     */
    private static boolean insideNoFlyZone(List<Polygon> noFlyZones, Point move){
        var isInside = false;
        // will return true if the Point is inside ANY of the no-fly zones
        // using the MapBox TurfJoins.inside method to check whether the Point is inside a Polygon
        for(Polygon nfz : noFlyZones) {
            isInside = isInside || inside(
                    com.mapbox.geojson.Point.fromLngLat(move.lng(), move.lat()),
                    nfz.getAsMapboxPolygon());
        }
        return isInside;
    }

    /**
     * Check whether there is more than one occurrence of a DroneMove in a List of DroneMoves
     * @param moves List of DroneMoves
     * @param newMove DroneMove
     * @return true if there is more than one occurrence, false otherwise
     */
    private static boolean moreThanOneOccurrence(List<DroneMove> moves, DroneMove newMove){
        // gets the size of the list that only contains DroneMoves that are equal to newMove
        int occurrences = moves.stream().filter(p -> p.equals(newMove)).toList().size();
        return occurrences > 1;
    }

    /**
     * Uses the ApproximateSegment method to approximate an entire path from start to end
     * @param exactPath List of LineSegments that need to be approximated
     * @param noFlyZones List of Polygons containing the no-fly zones
     * @return List of DroneMove
     */
    public static List<DroneMove> approximatePath(List<LineSegment> exactPath, List<Polygon> noFlyZones){
        Logger logger = Logger.getInstance();
        // verify there are no null arguments
        if (exactPath == null || noFlyZones == null){
            logger.logAction("LineApproximation.approximatePath(exactPath, noFlyZones", LogStatus.LINE_APPROXIMATION_NULL_ARGUMENT);
            return new ArrayList<>();
        }

        // create List, initialise with the approximate path of the first LineSegment of the exact path
        List<DroneMove> approximatePath = new ArrayList<>(Objects.requireNonNull(
                approximateSegment(exactPath.get(0).p1(), exactPath.get(0).p2(), noFlyZones)));

        // for each of the LineSegments after the first
        for (int i = 1; i < exactPath.size(); i++) {
            // get the Point where the line approximation got to
            var prevEndPoint = approximatePath.get(approximatePath.size()-1).to();
            // begin the approximation of the next LineSegment, using the previous endpoint as a starting point
            var segmentsToAdd = approximateSegment(prevEndPoint, exactPath.get(i).p2(), noFlyZones);
            // add all the approximated segments to a list
            approximatePath.addAll(segmentsToAdd);
        }
        logger.logAction("LineApproximation.approximatePath(exactPath, noFlyZones", LogStatus.LINE_APPROXIMATION_APPROXIMATE_PATH_SUCCESS);
        return approximatePath;
    }

    private enum LogStatus{
        LINE_APPROXIMATION_NULL_ARGUMENT,
        LINE_APPROXIMATION_APPROXIMATE_PATH_SUCCESS
    }
}
